Now I need you to create the ReferenceLinesPage and all the methods that are needed. All the methods have to be implemented in the servicemanager, where I already created a space for them, under the Reference lines comment. 

The GUI window must have a general structure like this (I will be more specific below for each of the components): centered horizontally, on the top of the page, the title "Reference lines". Underneath the title I want to use QSplitter to have on the left side a table with the informations from the database (whose structure is specified below) and on the right the plot and the details of the selected line (QSplitter allows the user to drag the divider in the middle to resize the two parts). Then, underneath the Qsplitter I want 5 buttons: on the bottom left corner the "Back" button. On the right the "Delete", "Modify", "Duplicate" and the "Add" buttons.

I need you to implement a State-Based UI Toggling because from the initial page of my GUI I can go in the reference line page (already implemented). At this stage I have not already connected a board, therefore I can't push the "Add" button to add a reference line because this requires the board connection. So, I want that at the beginning the button is disabled and it enables only when I connect a RedPitaya board (that happens when in the ConnectionPage i select the board in the table and click the "connect" button (not implemented yet)). All the other buttons, and therefore methods are accessible already from the beginning. Another thing that has to be taken into account is that if the user enters in this page from the initial page and presses the "back" button, the gui has to turn back to the initial page. Instead, there will be the possibility to access to this page from a window after the connection of the board. In this case, when the user presses the "back" button, the GUI will not return to the initial page but will return to the page from which the user pressed the "Reference lines" button. Pay attention that, considering the fact that the LaserManager has not been defined yet (will be defined when the board is selected in the connection page), the wire connection from the "add" button to the associated LaserManager method will be done in the method of the general manager that initialize the LaserManager.

The database structure for the reference lines is the one you can see in the reference_lines folder. There is a reference_lines_inventory.yaml file that contains all the informations about the different lines but the data required for the plot that are contained in separate files. As you can see from the file, the main informations are: the name of the line that is given by the user when the line is saved, the board which created the reference line file, the date and time of the creation of the file in a specific format (when the user saves a reference line using the "Add" button that will be implemented later on), the file name that contains the x and y data for the plot of that specific reference line, the date and time at which the reference line has been modified using the "Modify" button, the polarity that is the sign of a particular property of the system (+ or -) that depends on the board configuration and, as final property, the lock_region that identifies the locking point of the line as a coulpe of x axis points. Then, for each line, the file file_name.npy contains the x and y data to plot it.

The table on the left side of the QSplitter must show all the informations that are contained in the reference_lines/reference_lines_inventory.yaml file. When the user clicks on a specific line, on the right side of QSplitter I want the plot of the corresponding reference line and, below it, a table with all its properties. The file that contains the x and y data for the plot is the .npy file named by the entry file_name in the database. In addition, I want to visualize the locking region. In particular, I want a red semitransparent region between the two x-axis lock_region points (a rectangle with extrema on the x axis the lock_region coordinates).

When the user selects a line in the left part of the QSplit and press the "delete" button, the delete_reference_line method must be triggered. This method deletes the associated entry in the .yaml file and the .npy file, refreshing the table afterward.

When the user selects a line in the left part of the QSplit and press the "modify" button, the right part of the QSplit must turn into a "Editing mode" and the "modify" button transforms into the "save" button. In this mode, the table underneath the plot shows the actual values but now these can be modified. When the user has modified the parameters, presses on the "save" button. This triggers the modify_reference_line method that modifies the yaml file and the tables are refreshed. The parameters that can be changed are: name, lock_region (both values). If the name is modified, also the old .npy file has to be renamed accordingly. If a parameter is changed, also the modified date is changed to the current one in the yaml file.

If there are no lines in the database, the "duplicate" button must be disabled. If there is at least one line in it, it enables.

When a row of the table is selected and the "duplicate" button is pressed, the duplicate_reference_line method is triggered. In this method a new entry of the database is created. This is an exact copy of the copied version and differs from it only by the name that will be the same name of the copied line with a "_COPY" attached. As a consequence, the new .npy file that is created will be the same as the original one but with a "_COPY" inside the name (If the initial name is "K_D2" and the file is named "K_D2_Red...", the new reference line will have a name "K_D2_COPY" and the associated file will begin with "K_D2_COPY_Red..."). The creation date of the new file will be the same as the original file (the physical data are the same) but the modified date has to be changed to the current date.
